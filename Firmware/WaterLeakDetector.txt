/*********************************************************************************************************
    WaterLeakDetector: Detect a water leak and sound the alarm!  This program reads two 
        water level sensor analog outputs, converts each to a voltage, thresholds the voltages to detect
        a water leak condition, integrates the thresholds to filter out false readings, introduces
        some hysteresis into the alarm/reset process, and indicates the alarm.  The program uses a 
        non-blocking delay that reads each sensor every 20 milliseconds and requires 5 readings above a 
        threshold for either sensor in order to trigger an alarm.  
        
        This program supports both an alarm and an indicator.  The indicator turns on and off
        based solely upon the threshold hysteresis.  The alarm also turns on and off based upon the
        threshold hysteresis but, additionally, mutes when a pushbutton is pressed and stays muted until the
        alarm indication is cleared.  Although two sensors are supported, there is only a single alarm
        indication.  Either sensor can trigger the alarm and both sensors must be in the non-alarm
        state for the alarm indication to be cleared.  
        
        The indicator is normally lit to show that the system is working.  The indicator flashes when 
        an alarm condition is detected (water level threshold) and remains flashing until the alarm 
        condition is cleared.  The alarm is a piezo buzzer that is pulsed whenever there is an alarm
        condition and the mute pushbutton has not been pressed.
        
        When a new alarm condition is sensed, a message to this effect is published to the cloud.
        
        This version of code also also includes a diff() function for computing time differences using 
        millis(), for use in non-blocking delay functionality.
        
        To Do:
        1.  add in DHT11 temperature and humidity measurement.
        2.  add in code to support a software "meter" using a micro servo
        3.  add in toggle switch and integrate temperature and humidiy measurements with the "meter"
        4.  add code to use the Blynk app for alarm notification and remote temperature/humidity readingout.
        NOTE: need to add toggle switch to schematic.  Consider a pullup on the alarm output of the Photon
            so that the piezo buzzer does not go off when flashing new code.
        
    author: Bob Glicksman, 02/04/2017
    
    (c) 2017, Bob Glicksman and Jim Schrempp, Team Practical Projects
***********************************************************************************************************/
#define IFTTT_NOTIFY    // comment out if IFTTT alarm notification is not desired

// Constants and definitions
const int WATER_SENSOR_A_PIN = A0;
const int WATER_SENSOR_B_PIN = A1;
const int LED_PIN = D7;
const int ALARM_PIN = D6;
const int INDICATOR_PIN = D5;
const int BUTTON_PIN = D4;

const float WATER_LEVEL_THRESHOLD = 0.5;    // 0.5 volts or higher on either sensor triggers alarm

// Globals
boolean ledState = false;   // D7 LED is used for indicating water level measurements

// setup()
void setup() {
    pinMode(LED_PIN, OUTPUT);
    pinMode(ALARM_PIN, OUTPUT);
    pinMode(INDICATOR_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
   
}  // end of setup()

// loop()
void loop() {
    static boolean mute = false;  // set to true to mute the audible alarm
    static boolean indicator = false;  // set to true to flash the indicator
    static boolean alarm = false;   // set to true to sound the alarm
    static boolean previousAlarmState = false;  // used to detect a new alarm
    
    // measure and test water level at pre-determined interval
    if(nbWaterMeasureInterval(20) == false) {  // 20 ms between sensor readings
        // toggle the D7 LED to indicate loop timing for testing
        ledState = !ledState;
        if (ledState) {
            digitalWrite(LED_PIN, HIGH);
        } else {
            digitalWrite(LED_PIN, LOW);
        }
        
        // read the water level from the sensor; convert to a voltage value
        int waterLevelA, waterLevelB;
        float waterSensorVoltageA, waterSensorVoltageB;
        
        waterLevelA = analogRead(WATER_SENSOR_A_PIN);
        waterLevelB = analogRead(WATER_SENSOR_B_PIN);
        waterSensorVoltageA = ((float)waterLevelA * 3.3) / 4095;
        waterSensorVoltageB = ((float)waterLevelB * 3.3) / 4095;
        
        // integrate and threshold measurement for alarm
        if(alarmIntegrator(waterSensorVoltageA, waterSensorVoltageB) == true) {
            indicator = true;
            if(mute == false) {
                alarm = true;
            } else {
                alarm = false;                
            }
        } else {
            indicator = false;
            alarm = false;
            mute = false;   // reset alarm muting
        }
        
        #ifdef IFTTT_NOTIFY 
            //  For IFTTT Notification: test if new alarm and publish it
           if((indicator == true) && (indicator != previousAlarmState)) {
             Particle.publish("Water leak alarm", Time.timeStr(Time.now()) + " Z");
           }
           previousAlarmState = indicator; // update old alarm state to present state
         #endif
    }
    
    // process the mute pushbutton
    if(readPushButton() == true) {
        mute = true; // set the alarm mute flag
        alarm = false; // mute the alarm right now      
    }
    
    // refresh non-blocking alarm & indicator status
    nbFlashIndicator(indicator);
    nbSoundAlarm(alarm);
    
} // end of loop()

/* alarmIntegrator():  function that thresholds sensor voltage readings and integrates the values.
    parameters:
        sensorReading - the sensor voltage reading to be thresholded and integrated
    return:
        the alarm value as a boolean.  The alarm value is set after 5 thresholds are accumulated
            for either sensor and stays set until 5 under-thresholds are accumulated for both sensors
*/

boolean alarmIntegrator(float sensorAReading, float sensorBReading) {
    const byte ALARM_LIMIT = 5;     // 5 thresholds are required to trigger an alarm, then 5 under thresholds
                                    //  are required to reset the alarm condition.
                                    
    static byte integratedValueA = 0; // threshold exceeded accumulator for sensor A
    static byte integratedValueB = 0; // threshold exceeded accumulator for sensor B
    static boolean lastAlarmState = false;
    boolean thresholdedReadingA;
    boolean thresholdedReadingB;
    
   // test to see if threshold was exceeded on each sensor
    if(sensorAReading > WATER_LEVEL_THRESHOLD) {
        thresholdedReadingA = true;
    } else {
        thresholdedReadingA = false;
    }
    
    if(sensorBReading > WATER_LEVEL_THRESHOLD) {
        thresholdedReadingB = true;
    } else {
        thresholdedReadingB = false;
    }
    
    // integrate thresholds or under thresholds; clamp them at ALARM_LIMIT and 0
    if(thresholdedReadingA == true)  {       // increment integrator 
        if(integratedValueA < ALARM_LIMIT)  {
            integratedValueA++;
        } else {
            integratedValueA = ALARM_LIMIT;  // clamp at max value
        }
    } else {    // thresholdedReading was false
        if(integratedValueA > 0) {           // decrement integrator
            integratedValueA--;
        }  else  {
            integratedValueA = 0;    // clamp at zero
        }
    }
    
    if(thresholdedReadingB == true)  {       // increment integrator 
        if(integratedValueB < ALARM_LIMIT)  {
            integratedValueB++;
        } else {
            integratedValueB = ALARM_LIMIT;  // clamp at max value
        }
    } else {    // thresholdedReading was false
        if(integratedValueB > 0) {           // decrement integrator
            integratedValueB--;
        }  else  {
            integratedValueB = 0;    // clamp at zero
        }
    }
    
    
    // Determine the return value
    if((integratedValueA >= ALARM_LIMIT) || (integratedValueB >= ALARM_LIMIT)) {    // either integrator at the limit
        lastAlarmState = true;
        return true;
    } else {
        if((integratedValueA <= 0) && (integratedValueB <= 0)) {    // both integrators at zero
            lastAlarmState = false;
            return false;
        } else {
            return lastAlarmState;  // in between condition, no change in alarm return value
        }
    }
}  // end of alarmIntegrator()

/* nbFlashIndicator():  non-blocking function to flash the indicator LED when alarming
                        or light it constantly when not alarming
    parameters:
        flash - true to flash the LED, false to light it constantly
*/
void nbFlashIndicator(boolean flash) {
    const unsigned long FLASH_INTERVAL = 150; // 150 ms on and off
    static boolean lastOn = true;   // start with LED on
    static unsigned long lastTime = millis();
    
    if(flash == true) {     // flashes the LED
        if(diff(millis(), lastTime) >= FLASH_INTERVAL) { // flip the LED state
            lastOn = !lastOn;
            lastTime = millis();
        }
            
    } else {  // not flashing the LED
        lastOn = true;
    }
    
    if(lastOn == true)  {
        digitalWrite(INDICATOR_PIN, HIGH);
    } else {
        digitalWrite(INDICATOR_PIN, LOW);
    }
    return;
}   // end of nbFlashIndicator()

/* nbSoundAlarm():  non-blocking function to sound the alarm
    parameters:
        sound - sound the audible alarm
*/
void nbSoundAlarm(boolean sound) {
    const unsigned long BEEP_INTERVAL = 50; // 50 ms on and off
    static boolean lastOn = false;   // start with alarm off
    static unsigned long lastTime = millis();
    
    if(sound == true) {     // sound the buzzer
        if(diff(millis(), lastTime) >= BEEP_INTERVAL) { // flip the buzzer state
            lastOn = !lastOn;
            lastTime = millis();
        }
            
    } else {  // not alarming
        lastOn = false;
    }
    
    if(lastOn == true)  {
        digitalWrite(ALARM_PIN, HIGH);
    } else {
        digitalWrite(ALARM_PIN, LOW);
    }
    return;
}   // end of nbSoundAlarm()

/* nbWaterMeasureInterval(): non-blocking interval delay for water level measurements
    parameters:
        delayTime - number of milliseconds in the delay
    retrun:
        delay in progress - true if delay is in progress, otherwise false
*/
boolean nbWaterMeasureInterval(unsigned long delayTime) {
    static boolean lastState = false;
    static unsigned long lastTime;
    static unsigned long currentTime;
    
    // if not currently in timing, start timing
    if(lastState == false) {
        lastTime = millis();
        lastState = true;   // in measurement
        return true;
    }
    
    // currently timing, so test for completion and process accordingly
    currentTime = millis();
    if(diff(currentTime, lastTime) < delayTime) { // time not yet expired
        lastState = true;  // timing in process
        return true;
    } else {  // time has expired
        lastTime = currentTime;
        lastState = false;  // timing has expired
        return false;
    }
}  // end of nbWaterMeasureInterval

/* readPushButton: read the mute pushbutton with debouncing
    parameters: none
    return:
        flag that indicates the push button status
*/
boolean readPushButton() {
    const unsigned long DEBOUNCE_TIME = 10;  // 10 milliseconds
    
    // state variable states
    const byte OFF = 0;
    const byte DEBOUNCING = 1;
    const byte DEBOUNCED = 2;
    
    static byte lastState = OFF;
    static unsigned long beginTime;
    
    if(digitalRead(BUTTON_PIN) == LOW) {  // button has been pressed
        switch (lastState) {
            case OFF:       // new button press
                beginTime = millis();
                lastState = DEBOUNCING;
                return false;
                break;
            case DEBOUNCING:    // wait until debouncing time is over
                if(diff(millis(), beginTime) < DEBOUNCE_TIME) {
                    return false;
                } else {
                    lastState = DEBOUNCED;
                    return true;
                }
                break;
            case DEBOUNCED:     // stay in this state until button is released
                return false;
                break;
            default:
                return false;
        }
        
    } else {        // the button has been released
        lastState = OFF;
        return false;
    }
}  // end of readPushButton


/* diff(): function to measure time differences using millis() that corrects for millis() overflow.
    paramters:
        current - the current time value from millis(), as unsigned long
        last - the previous time value from millis(), as unsigned long
    return:
        the difference between current and last, as unsigned long
*/
unsigned long diff(unsigned long current, unsigned long last)  {
    const unsigned long MAX = 0xffffffff;  // an unsigned long is 4 bytes
    unsigned long difference;
    
    if (current < last) {       // overflow condition
        difference = (MAX - last) + current;
    } else {
        difference = current - last;
    }
    return difference;
}  // end of diff()

