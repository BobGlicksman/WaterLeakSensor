/*********************************************************************************************************
    WaterLevelSensor03: test program for water level sensing and thresholding.  This program reads a 
        water level sensor analog output, converts it to a voltage, thresholds the voltage to detect
        a water leak condition, integrates the thresholds to filter out false readings and introduce
        some hysteresis into the alarm/reset process, and indicate the alarm.  The program uses a non-blocking
        delay to loop once every 2 seconds for testing purposes only.  Normally, a short delay (e.g. 2 ms)
        should be used between water level sensor readings.  
        
        This version of the code supports both an alarm and an indicator.  The indicator turns on and off
        based solely upon the threshold hysteresis.  The alarm also turns on and off based upon the
        threshold hysteresis, but also mutes when a pushbutton is pressed and stays muted until the
        alarm indication is cleared.
        
        This version of code also also includesa diff() function for computing time differences using 
        millis(), for use in non-blocking delay functionality.
        
        YET TO DO:  the following needs to be added and tested to fully implement water level sensing:
        1.  pulse the alarm for better effect
        2.  light the indicator when not alarming, but flash the indicator when alarming.
        3.  add support for a second water level sensor
        
    author: Bob Glicksman, 01/21/2017
    
    (c) 2017, Bob Glicksman and Jim Schrempp, Team Practical Projects
***********************************************************************************************************/
// Constants and definitions
const int WATER_SENSOR_PIN = A0;
const int LED_PIN = D7;
const int ALARM_PIN = D6;
const int INDICATOR_PIN = D5;
const int BUTTON_PIN = D4;

const float WATER_LEVEL_THRESHOLD = 0.5;    // 0.5 volts or higher on sensor triggers alarm

// Globals
boolean ledState = false;
boolean alarm = false;      // state of water level alarm condition

// setup()
void setup() {
    pinMode(LED_PIN, OUTPUT);
    pinMode(ALARM_PIN, OUTPUT);
    pinMode(INDICATOR_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
   
}  // end of setup()

// loop()
void loop() {
    static boolean mute = false;  // set to true to mute the audible alarm
    
    // measure and test water level at pre-determined interval
    if(nbWaterMeasureInterval(2000) == false) {
        // toggle the D7 LED to indicate loop timing for testing
        ledState = !ledState;
        if (ledState) {
            digitalWrite(LED_PIN, HIGH);
        } else {
            digitalWrite(LED_PIN, LOW);
        }
        
        // read the water level from the sensor; convert to a voltage value
        int waterLevel;
        float waterSensorVoltage;
        String publishedData;
        
        waterLevel = analogRead(WATER_SENSOR_PIN);
        waterSensorVoltage = ((float)waterLevel * 3.3) / 4095;
    
    //    Particle.publish("Sensor Value:", String(waterLevel));
        Particle.publish("Sensor Voltage:", String(waterSensorVoltage));  // log to the Partcile console
        
        // integrate and threshold measurement for alarm
        if(alarmIntegrator(waterSensorVoltage) == true) {
            digitalWrite(INDICATOR_PIN, HIGH);
            if(mute == false) {
                digitalWrite(ALARM_PIN, HIGH);
            } else {
                digitalWrite(ALARM_PIN, LOW);                
            }
        } else {
            digitalWrite(INDICATOR_PIN, LOW);
            digitalWrite(ALARM_PIN, LOW);
            mute = false;   // reset alarm muting
        }
    }
    
    // process the mute pushbutton
    if(readPushButton() == true) {
        mute = true; // set the alarm mute flag
        digitalWrite(ALARM_PIN, LOW); // mute the alarm right now      
    }
    
} // end of loop()

/* alarmIntegrator():  function that thresholds sensor voltage readings and integrates the values.
    parameters:
        sensorReading - the sensor voltage reading to be thresholded and integrated
    return:
        the alarm value as a boolean.  The alarm value is set after 5 thresholds are accumulated
            and stays set until 5 under-thresholds are accumulated
*/

boolean alarmIntegrator(float sensorReading) {
    const byte ALARM_LIMIT = 5;     // 5 thresholds are required to trigger an alarm, then 5 under thresholds
                                    //  are required to reset the alarm condition.
                                    
    static byte integratedValue = 0;
    static boolean lastAlarmState = false;
    boolean thresholdedReading;
    
   // test to see if threshold was exceeded
    if(sensorReading > WATER_LEVEL_THRESHOLD) {
        thresholdedReading = true;
    } else {
        thresholdedReading = false;
    }
    
    // integrate thresholds or under thresholds
    if(thresholdedReading == true)  {       // increment integrator 
        if(integratedValue < ALARM_LIMIT)  {
            integratedValue++;
        } else {
            integratedValue = ALARM_LIMIT;  // clamp at max value
        }
    } else {    // thresholdedReading was false
        if(integratedValue > 0) {           // decrement integrator
            integratedValue--;
        }  else  {
            integratedValue = 0;    // clamp at zero
        }
    }
    
    Particle.publish("Integrator Value", String(integratedValue));  // test only
    
    if(integratedValue >= ALARM_LIMIT) {
        lastAlarmState = true;
        return true;
    } else {
        if(integratedValue <= 0) {
            lastAlarmState = false;
            return false;
        } else {
            return lastAlarmState;
        }
    }
}  // end of alarmIntegrator()

/* nbWaterMeasureInterval(): non-blocking interval delay for water level measurements
    parameters:
        delayTime - number of milliseconds in the delay
    retrun:
        delay in progress - true if delay is in progress, otherwise false
*/
boolean nbWaterMeasureInterval(unsigned long delayTime) {
    static boolean lastState = false;
    static unsigned long lastTime;
    static unsigned long currentTime;
    
    // if not currently in timing, start timing
    if(lastState == false) {
        lastTime = millis();
        lastState = true;   // in measurement
        return true;
    }
    
    // currently timing, so test for completion and process accordingly
    currentTime = millis();
    if(diff(currentTime, lastTime) < delayTime) { // time not yet expired
        lastState = true;  // timing in process
        return true;
    } else {  // time has expired
        lastTime = currentTime;
        lastState = false;  // timing has expired
        return false;
    }
}  // end of nbWaterMeasureInterval

/* readPushButton: read the mute pushbutton with debouncing
    parameters: none
    return:
        flag that indicates the push button status
*/
boolean readPushButton() {
    const unsigned long DEBOUNCE_TIME = 10;  // 10 milliseconds
    
    // state variable states
    const byte OFF = 0;
    const byte DEBOUNCING = 1;
    const byte DEBOUNCED = 2;
    
    static byte lastState = OFF;
    static unsigned long beginTime;
    
    if(digitalRead(BUTTON_PIN) == LOW) {  // button has been pressed
        switch (lastState) {
            case OFF:       // new button press
                beginTime = millis();
                lastState = DEBOUNCING;
                return false;
                break;
            case DEBOUNCING:    // wait until debouncing time is over
                if(diff(millis(), beginTime) < DEBOUNCE_TIME) {
                    return false;
                } else {
                    lastState = DEBOUNCED;
                    return true;
                }
                break;
            case DEBOUNCED:     // stay in this state until button is released
                return false;
                break;
            default:
                return false;
        }
        
    } else {        // the button has been released
        lastState = OFF;
        return false;
    }
}  // end of readPushButton


/* diff(): function to measure time differences using millis() that corrects for millis() overflow.
    paramters:
        current - the current time value from millis(), as unsigned long
        last - the previous time value from millis(), as unsigned long
    return:
        the difference between current and last, as unsigned long
*/
unsigned long diff(unsigned long current, unsigned long last)  {
    const unsigned long MAX = 0xffffffff;  // an unsigned long is 4 bytes
    unsigned long difference;
    
    if (current < last) {       // overflow condition
        difference = (MAX - last) + current;
    } else {
        difference = current - last;
    }
    return difference;
}  // end of diff()

