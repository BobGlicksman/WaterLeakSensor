/*********************************************************************************************************
    WaterLevelSensor04: test program for water level sensing and thresholding.  This program reads a 
        water level sensor analog output, converts it to a voltage, thresholds the voltage to detect
        a water leak condition, integrates the thresholds to filter out false readings and introduce
        some hysteresis into the alarm/reset process, and indicate the alarm.  The program uses a non-blocking
        delay to loop once every 2 seconds for testing purposes only.  Normally, a short delay (e.g. 2 ms)
        should be used between water level sensor readings.  
        
        This version of the code supports both an alarm and an indicator.  The indicator turns on and off
        based solely upon the threshold hysteresis.  The alarm also turns on and off based upon the
        threshold hysteresis, but also mutes when a pushbutton is pressed and stays muted until the
        alarm indication is cleared.  
        
        The indicator is normally lit to show that the system is working.  The indicator flashes when 
        an alarm condition is detected (water level threshold) and remains flashing until the alarm 
        condition is cleared.  The alarm is a piezo buzzer that is pulsed whenever there is an alarm
        condition and the mute pushbutton has not been pressed.
        
        When a new alarm condition is sensed, a message to this effect is published to the cloud.
        
        This version of code also also includes a diff() function for computing time differences using 
        millis(), for use in non-blocking delay functionality.
        
        YET TO DO:  the following needs to be added and tested to fully implement water level sensing:
        1.  add support for a second water level sensor
        2.  remove cloud publications for testing only and reduce water level reading interval to a few
            milliseconds instead of 2 seconds (used for testing).
        
    author: Bob Glicksman, 01/25/2017
    
    (c) 2017, Bob Glicksman and Jim Schrempp, Team Practical Projects
***********************************************************************************************************/
// Constants and definitions
const int WATER_SENSOR_PIN = A0;
const int LED_PIN = D7;
const int ALARM_PIN = D6;
const int INDICATOR_PIN = D5;
const int BUTTON_PIN = D4;

const float WATER_LEVEL_THRESHOLD = 0.5;    // 0.5 volts or higher on sensor triggers alarm

// Globals
boolean ledState = false;   // D7 LED is used for indicating water level measurements

// setup()
void setup() {
    pinMode(LED_PIN, OUTPUT);
    pinMode(ALARM_PIN, OUTPUT);
    pinMode(INDICATOR_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
   
}  // end of setup()

// loop()
void loop() {
    static boolean mute = false;  // set to true to mute the audible alarm
    static boolean indicator = false;  // set to true to flash the indicator
    static boolean alarm = false;   // set to true to sound the alarm
    static boolean previousAlarmState = false;  // used to detect a new alarm
    
    // measure and test water level at pre-determined interval
    if(nbWaterMeasureInterval(2000) == false) {
        // toggle the D7 LED to indicate loop timing for testing
        ledState = !ledState;
        if (ledState) {
            digitalWrite(LED_PIN, HIGH);
        } else {
            digitalWrite(LED_PIN, LOW);
        }
        
        // read the water level from the sensor; convert to a voltage value
        int waterLevel;
        float waterSensorVoltage;
        String publishedData;
        
        waterLevel = analogRead(WATER_SENSOR_PIN);
        waterSensorVoltage = ((float)waterLevel * 3.3) / 4095;
    
    //    Particle.publish("Sensor Value:", String(waterLevel));
        Particle.publish("Sensor Voltage:", String(waterSensorVoltage));  // log to the Partcile console
        
        // integrate and threshold measurement for alarm
        if(alarmIntegrator(waterSensorVoltage) == true) {
            indicator = true;
            if(mute == false) {
                alarm = true;
            } else {
                alarm = false;                
            }
        } else {
            indicator = false;
            alarm = false;
            mute = false;   // reset alarm muting
        }
        
        //  test if new alarm and publish it
        if((indicator == true) && (indicator != previousAlarmState)) {
            Particle.publish("Water leak alarm", Time.timeStr(Time.now()) + " Z");
        }
        previousAlarmState = indicator; // update old alarm state to present state
    }
    
    // process the mute pushbutton
    if(readPushButton() == true) {
        mute = true; // set the alarm mute flag
        alarm = false; // mute the alarm right now      
    }
    
    // refresh non-blocking alarm & indicator status
    nbFlashIndicator(indicator);
    nbSoundAlarm(alarm);
    
} // end of loop()

/* alarmIntegrator():  function that thresholds sensor voltage readings and integrates the values.
    parameters:
        sensorReading - the sensor voltage reading to be thresholded and integrated
    return:
        the alarm value as a boolean.  The alarm value is set after 5 thresholds are accumulated
            and stays set until 5 under-thresholds are accumulated
*/

boolean alarmIntegrator(float sensorReading) {
    const byte ALARM_LIMIT = 5;     // 5 thresholds are required to trigger an alarm, then 5 under thresholds
                                    //  are required to reset the alarm condition.
                                    
    static byte integratedValue = 0;
    static boolean lastAlarmState = false;
    boolean thresholdedReading;
    
   // test to see if threshold was exceeded
    if(sensorReading > WATER_LEVEL_THRESHOLD) {
        thresholdedReading = true;
    } else {
        thresholdedReading = false;
    }
    
    // integrate thresholds or under thresholds
    if(thresholdedReading == true)  {       // increment integrator 
        if(integratedValue < ALARM_LIMIT)  {
            integratedValue++;
        } else {
            integratedValue = ALARM_LIMIT;  // clamp at max value
        }
    } else {    // thresholdedReading was false
        if(integratedValue > 0) {           // decrement integrator
            integratedValue--;
        }  else  {
            integratedValue = 0;    // clamp at zero
        }
    }
    
    Particle.publish("Integrator Value", String(integratedValue));  // test only
    
    if(integratedValue >= ALARM_LIMIT) {
        lastAlarmState = true;
        return true;
    } else {
        if(integratedValue <= 0) {
            lastAlarmState = false;
            return false;
        } else {
            return lastAlarmState;
        }
    }
}  // end of alarmIntegrator()

/* nbFlashIndicator():  non-blocking function to flash the indicator LED when alarming
                        or light it constantly when not alarming
    parameters:
        flash - true to flash the LED, false to light it constantly
*/
void nbFlashIndicator(boolean flash) {
    const unsigned long FLASH_INTERVAL = 150; // 150 ms on and off
    static boolean lastOn = true;   // start with LED on
    static unsigned long lastTime = millis();
    
    if(flash == true) {     // flashs the LED
        if(diff(millis(), lastTime) >= FLASH_INTERVAL) { // flip the LED state
            lastOn = !lastOn;
            lastTime = millis();
        }
            
    } else {  // not flashing the LED
        lastOn = true;
    }
    if(lastOn == true)  {
        digitalWrite(INDICATOR_PIN, HIGH);
    } else {
        digitalWrite(INDICATOR_PIN, LOW);
    }
    return;
}   // end of nbFlashIndicator()

/* nbSoundAlarm():  non-blocking function to sound the alarm
    parameters:
        sound - sound the audible alarm
*/
void nbSoundAlarm(boolean sound) {
    const unsigned long BEEP_INTERVAL = 250; // 250 ms on and off
    static boolean lastOn = false;   // start with alarm off
    static unsigned long lastTime = millis();
    
    if(sound == true) {     // flashs the LED
        if(diff(millis(), lastTime) >= BEEP_INTERVAL) { // flip the buzzer state
            lastOn = !lastOn;
            lastTime = millis();
        }
            
    } else {  // not alarming
        lastOn = false;
    }
    if(lastOn == true)  {
        digitalWrite(ALARM_PIN, HIGH);
    } else {
        digitalWrite(ALARM_PIN, LOW);
    }
    return;
}   // end of nbSoundAlarm()

/* nbWaterMeasureInterval(): non-blocking interval delay for water level measurements
    parameters:
        delayTime - number of milliseconds in the delay
    retrun:
        delay in progress - true if delay is in progress, otherwise false
*/
boolean nbWaterMeasureInterval(unsigned long delayTime) {
    static boolean lastState = false;
    static unsigned long lastTime;
    static unsigned long currentTime;
    
    // if not currently in timing, start timing
    if(lastState == false) {
        lastTime = millis();
        lastState = true;   // in measurement
        return true;
    }
    
    // currently timing, so test for completion and process accordingly
    currentTime = millis();
    if(diff(currentTime, lastTime) < delayTime) { // time not yet expired
        lastState = true;  // timing in process
        return true;
    } else {  // time has expired
        lastTime = currentTime;
        lastState = false;  // timing has expired
        return false;
    }
}  // end of nbWaterMeasureInterval

/* readPushButton: read the mute pushbutton with debouncing
    parameters: none
    return:
        flag that indicates the push button status
*/
boolean readPushButton() {
    const unsigned long DEBOUNCE_TIME = 10;  // 10 milliseconds
    
    // state variable states
    const byte OFF = 0;
    const byte DEBOUNCING = 1;
    const byte DEBOUNCED = 2;
    
    static byte lastState = OFF;
    static unsigned long beginTime;
    
    if(digitalRead(BUTTON_PIN) == LOW) {  // button has been pressed
        switch (lastState) {
            case OFF:       // new button press
                beginTime = millis();
                lastState = DEBOUNCING;
                return false;
                break;
            case DEBOUNCING:    // wait until debouncing time is over
                if(diff(millis(), beginTime) < DEBOUNCE_TIME) {
                    return false;
                } else {
                    lastState = DEBOUNCED;
                    return true;
                }
                break;
            case DEBOUNCED:     // stay in this state until button is released
                return false;
                break;
            default:
                return false;
        }
        
    } else {        // the button has been released
        lastState = OFF;
        return false;
    }
}  // end of readPushButton


/* diff(): function to measure time differences using millis() that corrects for millis() overflow.
    paramters:
        current - the current time value from millis(), as unsigned long
        last - the previous time value from millis(), as unsigned long
    return:
        the difference between current and last, as unsigned long
*/
unsigned long diff(unsigned long current, unsigned long last)  {
    const unsigned long MAX = 0xffffffff;  // an unsigned long is 4 bytes
    unsigned long difference;
    
    if (current < last) {       // overflow condition
        difference = (MAX - last) + current;
    } else {
        difference = current - last;
    }
    return difference;
}  // end of diff()
