/*********************************************************************************************************
    WaterLevelSensor02: test program for water level sensing and thresholding.  This program reads a 
        water level sensor analog output, converts it to a voltage, thresholds the voltage to detect
        a water leak condition, integrates the thresholds to filter out false readings and introduce
        some hysteresis into the alarm/reset process, and indicate the alarm.  The program uses a blocking
        delay to loop once every 3 seconds for testing purposes only.  Normally, a short delay (e.g. 1 ms)
        should be used between water level sensor readings.  This version of code also also includesa diff()
        function for computing time differences using millis(), for later use in non-blocking delay
        functionality.
        
    author: Bob Glicksman, 01/19/2017
    
    (c) 2017, Bob Glicksman and Jim Schrempp, Team Practical Projects
***********************************************************************************************************/
// Constants and definitions
const int WATER_SENSOR_PIN = A0;
const int LED_PIN = D7;
const int ALARM_PIN = D6;

const float WATER_LEVEL_THRESHOLD = 0.5;    // 0.5 volts or higher on sensor triggers alarm

// Globals
boolean ledState = false;
boolean alarm = false;      // state of water level alarm condition

// setup()
void setup() {
    pinMode(LED_PIN, OUTPUT);
    pinMode(ALARM_PIN, OUTPUT);
   
}  // end of setup()

// loop()
void loop() {

    ledState = !ledState;
    if (ledState) {
        digitalWrite(LED_PIN, HIGH);
    } else {
        digitalWrite(LED_PIN, LOW);
    }
    
    int waterLevel;
    float waterSensorVoltage;
    String publishedData;
    
    waterLevel = analogRead(WATER_SENSOR_PIN);
    waterSensorVoltage = ((float)waterLevel * 3.3) / 4095;

//    Particle.publish("Sensor Value:", String(waterLevel));
    Particle.publish("Sensor Voltage:", String(waterSensorVoltage));
    
    if(alarmIntegrator(waterSensorVoltage) == true) {
        digitalWrite(ALARM_PIN, HIGH);
    } else {
        digitalWrite(ALARM_PIN, LOW);
    }
    
    // blocking delay for testing purposes only
    delay(3000);
} // end of loop()

/* alarmIntegrator():  function that thresholds sensor voltage readings and integrates the vlaues.
    parameters:
        sensorReading - the sensor voltage reading to be thresholded and integrated
    return:
        the alarm value as a boolean.  The alarm value is set after 5 thresholds are accumulated
            and stays set until 5 under-thresholds are accumulated
*/

boolean alarmIntegrator(float sensorReading) {
    const byte ALARM_LIMIT = 5;     // 5 thresholds are required to trigger an alarm, then 5 under thresholds
                                    //  are required to reset the alarm condition.
                                    
    static byte integratedValue = 0;
    static boolean lastAlarmState = false;
    boolean thresholdedReading;
    
   // test to see if threshold was exceeded
    if(sensorReading > WATER_LEVEL_THRESHOLD) {
        thresholdedReading = true;
    } else {
        thresholdedReading = false;
    }
    
    // integrate thresholds or under thresholds
    if(thresholdedReading == true)  {       // increment integrator 
        if(integratedValue < ALARM_LIMIT)  {
            integratedValue++;
        } else {
            integratedValue = ALARM_LIMIT;  // clamp at max value
        }
    } else {    // thresholdedReading was false
        if(integratedValue > 0) {           // decrement integrator
            integratedValue--;
        }  else  {
            integratedValue = 0;    // clamp at zero
        }
    }
    
    Particle.publish("Integrator Value", String(integratedValue));  // test only
    
    if(integratedValue >= ALARM_LIMIT) {
        lastAlarmState = true;
        return true;
    } else {
        if(integratedValue <= 0) {
            lastAlarmState = false;
            return false;
        } else {
            return lastAlarmState;
        }
    }
}  // end of alarmIntegrator()

/* diff(): function to measure time differences using millis() that corrects for millis() overflow.
    paramters:
        current - the current time value from millis(), as unsigned long
        last - the previous time value from millis(), as unsigned long
    return:
        the difference between current and last, as unsigned long
*/
unsigned long diff(unsigned long current, unsigned long last)  {
    const unsigned long MAX = 0xffffffff;  // an unsigned long is 4 bytes
    unsigned long difference;
    
    if (current < last) {       // overflow condition
        difference = (MAX - last) + current;
    } else {
        difference = current - last;
    }
    return difference;
}  // end of diff()

